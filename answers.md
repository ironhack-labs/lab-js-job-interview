1. Challenge 1:
  - Answer: b
  - Explanation: Because we are renaming the variable in the function, so it changes the value in the global scope.


2. Challenge 2:
  - Answer: a
  - Explanation: I thought it was like the challenge 1, but I see that the function has the parameter, which is passed as the argument and changed it. So the correct answer is c. I had it wrong.


3. Challenge 3:
  - Answer:c
  - Explanation:Because of the hoisting, if you invoke the function before declaring it, it will be read regardless of when it is invoked.


4. Challenge 4:
  - Answer:c
  - Explanation:Because of the mutability of non-primitive data. That so, we are changing a value inside the object, not the object per se. So it will be changed no matter what.


5. Bonus - Challenge 5:
  - Answer:c
  - Explanation: Because we are making the function before we are declaring new variables, so it changes de age of the rabbit1. Rabbit2, because is a new object, doesn't get affected by the obj.age.
